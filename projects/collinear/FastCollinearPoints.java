package collinear;import edu.princeton.cs.algs4.In;import edu.princeton.cs.algs4.StdDraw;import edu.princeton.cs.algs4.StdOut;import java.util.LinkedList;import java.util.Arrays;public class FastCollinearPoints {    private static final int MINIMUM_LENGTH = 4;    private final LinkedList<LineSegment> collinearLineSegments = new LinkedList<>();    /**     * Constructor of FastCollinearPoints.     */    public FastCollinearPoints(Point[] points) {        if (points == null) {            throw new IllegalArgumentException("The points can't be null.");        }        for (Point p : points) {            if (p == null) {                throw new IllegalArgumentException("Every point can't be null.");            }        }        int length = points.length;        for (int i = 0; i < length; i++) {            for (int j = i + 1; j < length; j++) {                if (points[i].compareTo(points[j]) == 0) {                    throw new IllegalArgumentException("Points can't repeat.");                }            }        }        if (length < MINIMUM_LENGTH) {            return;        }        Point[] sortedPoints = Arrays.copyOf(points, length);        Arrays.parallelSort(sortedPoints);        Point[] pointsBySlope = sortedPoints.clone();        for (Point point : points) {            Arrays.sort(pointsBySlope, point.slopeOrder());            for (int i = 0; i < length; ) {                int j = i + 1;                while (j < length && point.slopeTo(pointsBySlope[i]) == point.slopeTo(pointsBySlope[j])) {                    j++;                }                if (j - i >= 3 && pointsBySlope[0].compareTo(min(pointsBySlope, i, j - 1)) < 0) {                    collinearLineSegments.add(new LineSegment(pointsBySlope[0], max(pointsBySlope, i, j - 1)));                }                if (j == length) {                    break;                }                i = j;            }        }    }    private Point min(Point[] points, int low, int high) {        Point min = points[low];        for (int i = low + 1; i <= high; i++) {            if (points[i].compareTo(min) < 0) {                min = points[i];            }        }        return min;    }    private Point max(Point[] points, int low, int high) {        Point max = points[low];        for (int i = low + 1; i <= high; i++) {            if (points[i].compareTo(max) > 0) {                max = points[i];            }        }        return max;    }    /**     * @return the number of segments.     */    public int numberOfSegments() {        return collinearLineSegments.size();    }    /**     * @return the line segments.     */    public LineSegment[] segments() {        LineSegment[] lineSegments = new LineSegment[numberOfSegments()];        int index = 0;        for (LineSegment lineSegment : collinearLineSegments) {            lineSegments[index++] = lineSegment;        }        return lineSegments;    }    public static void main(String[] args) {        // read the n points from a file        In in = new In(args[0]);        int n = in.readInt();        Point[] points = new Point[n];        for (int i = 0; i < n; i++) {            int x = in.readInt();            int y = in.readInt();            points[i] = new Point(x, y);        }        // draw the points        StdDraw.enableDoubleBuffering();        StdDraw.setXscale(0, 32768);        StdDraw.setYscale(0, 32768);        for (Point p : points) {            p.draw();        }        StdDraw.show();        // print and draw the line segments        FastCollinearPoints collinear = new FastCollinearPoints(points);        for (LineSegment segment : collinear.segments()) {            StdOut.println(segment);            segment.draw();        }        StdDraw.show();    }}